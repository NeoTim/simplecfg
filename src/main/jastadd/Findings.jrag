/**
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.util.Collection;
import java.util.LinkedList;

/**
 * This aspect provides the general attributes to collect findings for the
 * available analyses.
 */
aspect Findings {
  /** Collection of API usage findings.  */
  coll Collection<String> CompilationUnit.findings()
    [new LinkedList<String>()]
    with add
    root CompilationUnit;

  /** Build a new finding with the given message.  */
  syn String ASTNode.finding(String message) {
    ASTNode location = locationNode();
    return String.format("%s:%d:%d: %s",
        sourceFile(), getLine(location.getStart()),
        getColumn(location.getStart()), message);
  }

  /** Find the closest AST node with source location information.  */
  syn ASTNode ASTNode.locationNode() {
    ASTNode node = this;
    while (node.getParent() != null && node.getStart() == 0) {
      node = node.getParent();
    }
    return node;
  }

  /** Find the indentation for the current statement.  */
  inh String Stmt.indentation();

  /** Find the indentation for the current expression.  */
  inh String Expr.indentation();

  /** Find the indentation for the current type declaration.  */
  inh String TypeDecl.indentation();

  eq Block.getChild().indentation() = indentation() + "  ";
  eq TypeDecl.getChild().indentation() = indentation() + "  ";

  eq CompilationUnit.getChild().indentation() = "";
  eq Program.getChild().indentation() = "";
}
