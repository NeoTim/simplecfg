/**
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Adds an analysis that checks for dereferences of a parameter declared nullable.
 * <p>
 * When a method or constructor parameter is annotated with javax.annotation.Nullable,
 * we check that all dereferences of that parameter are guarded by a null-check. The
 * analysis is control-flow sensitive in that it will recognize if all control flow paths
 * to the dereference are effectively guarded by a null check, for example: {@code
 * if (p == null) return;
 * p.x(); // Guarded by null check above.
 * }
 * <p>
 * The analysis also assumes that a method call to {@code checkNotNull}, or {@code isNotNull}
 * will also work as a null guard. There are more possible variations of methods guarding against
 * nullness that could be considered, but currently we only check for these methods:
 * <ul>
 * <li>{@code checkNotNull}, {@code checkNonNull}: assume that any control flow path following this
 * call with the analyzed parameter as the first argument are safe for dereferencing that parameter
 * <li>{@code isNotNull}, {@code isNonNull}: assume that calls to methods with names that start with
 * these prefixes guard the single argument against nullness
 * </ul>
 * <p>
 * To find potential null dereferences on nullable parameters, the analysis does a forward CFG
 * traversal from the entry-point of the method. Note that this is only done whenever a
 * {@code @Nullable} parameter has been encountered in the method. The traversal explores all paths
 * from the method entry until it finds null guard statements such as {@code if (p != null)}. The
 * branches that are protected from nullness get pruned in the search and the search continues on
 * other branches. The search is performed by a {@code NullDereferenceLocator}, which implements the
 * {@code CfgSearch} interface. This visitor is invoked for each node in the CFG search, and it
 * decides if the search will continue from that node, or if the current edge should be skipped
 * (i.e., pruned).
 * <p>
 * In order to find the position in the CFG where a potential null dereference occurs, CFG marker
 * nodes are inserted. This is done by adding a synthesized non-terminal attribute (NTA) for
 * a CfgMarker on AbstractDot (which represents Java dot expressions). This marker node appears
 * in the CFG as "nullable access" because it is inserted whenever a nullable variable is
 * dereferenced.
 * <p>
 * Dataflow analysis is not used, so in order to analyze a parameter it is required to be
 * effectively final, i.e. it is not assigned anywhere in side the body of the method/constructor.
 */
aspect NullableAnalysis {

  // Give ParameterDeclaration access to the inherited compilationUnit attribute.
  inh CompilationUnit ParameterDeclaration.compilationUnit();

  ParameterDeclaration contributes nullableDereferenceFinding()
      when nullableDereferenceFinding() != null
      to CompilationUnit.findings()
      for compilationUnit();

  /**
   * Generate a NullableDereference finding for this dot expression,
   * if no finding should be reported this attribute returns {@code null}.
   */
  syn lazy ExtendJFinding ParameterDeclaration.nullableDereferenceFinding() {
    if (!getModifiers().hasNullableAnnotation()) {
      return null;
    }
    if (!isFinal() && !isEffectivelyFinal()) {
      // Do not analyze non-effectively final parameters.
      return null;
    }
    Expr location = findNullableDereference(this);
    if (location == null) {
      return null;
    }
    ExtendJFinding finding = location.finding("NullableDereference", String.format(
        "Dereferencing %s, which was declared @Nullable.", name()));
    if (compilationUnit().fromSource()) {
      ASTNode modifierLocation = nullableModifierLocation();
      int line = getLine(modifierLocation.getStart());
      int startCol = getColumn(modifierLocation.getStart());
      int endCol = getColumn(modifierLocation.getEnd());
      if (startCol < endCol && line == getLine(modifierLocation.getEnd())) {
        try {
          InputStream data = compilationUnit().getClassSource().openInputStream();
          java.util.Scanner scanner = new java.util.Scanner(data);
          for (int i = 1; i < line && scanner.hasNextLine(); ++i) {
            scanner.nextLine();
          }
          if (scanner.hasNextLine()) {
            String text = scanner.nextLine();
            finding.addFix("Remove the @Nullable annotation.\n",
                line, line,
                text.substring(0,startCol-1) + text.substring(endCol+1));
          }
        } catch (IOException e) {
          // Failed to unparse the current line.
          // This is not a serious problem; we just don't give a fix suggestion.
        }
      }
    }
    return finding;
  }

  /**
   * Find the location node for the javax.annotation.Nullable annotation in the modifier list.
   * Returns {@code null} if the location of the modifier was not found.
   */
  syn ASTNode ParameterDeclaration.nullableModifierLocation() =
      getModifiers().nullableModifierLocation();

  syn ASTNode Modifiers.nullableModifierLocation() {
    for (Modifier modifier : getModifierList()) {
      if (modifier.isAnnotation("javax.annotation", "Nullable")) {
        return modifier.locationNode();
      }
    }
    return null;
  }

  /**
   * Find a location, not necessarily the first location, in the host method/constructor where the
   * parameter is accessed without a null guard.
   */
  inh Expr ParameterDeclaration.findNullableDereference(Variable var);

  eq Program.getChild().findNullableDereference(Variable var) = null;
  eq BodyDecl.getChild().findNullableDereference(Variable var) = null;

  eq MethodDecl.getParameter().findNullableDereference(Variable var) {
    if (!hasBlock()) {
      return null;
    }
    CfgNode cfgNode = entry().bfs(new NullDereferenceLocator(var));
    return cfgNode == null ? null : cfgNode.receiverExpr();
  }

  eq ConstructorDecl.getParameter().findNullableDereference(Variable var) {
    CfgNode cfgNode = entry().bfs(new NullDereferenceLocator(var));
    return cfgNode == null ? null : cfgNode.receiverExpr();
  }

  /**
   * A CFG visitor that searches in the forward CFG for a nullable dereference.
   * <p>
   * The search stops at parts of the search tree guarded by a null check on the receiver variable.
   */
  class NullDereferenceLocator implements CfgVisitor {
    private final Variable var;

    public NullDereferenceLocator(Variable var) {
      this.var = var;
    }

    @Override public SearchAction processEdge(CfgNode pred, CfgNode succ) {
      if (pred.isNullGuard(var, succ)) {
        return SearchAction.SKIP;
      }
      Expr receiver = succ.receiverExpr();
      if (receiver != null && receiver.isVariable(var) && !receiver.hasNullGuard(var)) {
        return SearchAction.SUCCESSOR_MATCH;
      }
      return SearchAction.CONTINUE;
    }
  }

  /**
   * Returns the receiver expression if the CFG node is the child of a dereference expression.
   * Returns {@code null} otherwise.
   */
  inh Expr CfgNode.receiverExpr();
  eq Program.getChild().receiverExpr() = null;
  eq BodyDecl.getChild().receiverExpr() = null;
  eq BodyDecl.exit().receiverExpr() = null;
  eq TryStmt.tryEntryMarker().receiverExpr() = null;
  eq BreakStmt.marker().receiverExpr() = null;
  eq ContinueStmt.marker().receiverExpr() = null;
  eq ReturnStmt.marker().receiverExpr() = null;
  eq MethodAccess.exceptionNode().receiverExpr() = null;
  eq MethodAccess.call().receiverExpr() =
      hasPrevExpr()
      ? prevExpr()
      : null;
  eq ThrowStmt.exceptionNode().receiverExpr() = null;
  eq TryStmt.exceptionNode().receiverExpr() = null;
  eq ConditionalExpr.branch().receiverExpr() = null;
  eq ConditionalExpr.thenEndMarker().receiverExpr() = null;
  eq ConditionalExpr.elseEndMarker().receiverExpr() = null;
  eq IfStmt.branch().receiverExpr() = null;
  eq IfStmt.thenEndMarker().receiverExpr() = null;
  eq IfStmt.elseEndMarker().receiverExpr() = null;
  eq ForStmt.branch().receiverExpr() = null;
  eq EnhancedForStmt.branch().receiverExpr() = null;
  eq WhileStmt.branch().receiverExpr() = null;
  eq DoStmt.branch().receiverExpr() = null;
  eq SwitchStmt.branch().receiverExpr() = null;
  eq LambdaBody.exit().receiverExpr() = null;
  eq AbstractDot.nullableDereferenceMarker().receiverExpr() = getLeft();

  /** Marker node used to find location of a nullable dereference in the CFG.  */
  syn nta CfgMarker AbstractDot.nullableDereferenceMarker() = new CfgMarker();

  /** Insert nullable dereference marker in the CFG.  */
  refine SimpleCFG
  eq AbstractDot.getLeft().follow() =
      getRight().isMethodAccess()
      ? refined()
      : nullableDereferenceMarker();

  eq AbstractDot.nullableDereferenceMarker().succ() = Collections.singleton(getRight().entry());

  syn boolean CfgNode.isNullGuard(Variable var, CfgNode succ) = false;

  /**
   * We assume that calling a method named checkNotNull on the variable var will throw an exception
   * if the argument is null.
   */
  eq CfgMethodCall.isNullGuard(Variable var, CfgNode succ) {
    if (succ instanceof CfgException) {
      return false;
    }
    MethodAccess access = methodAccess();
    return (access.name().equals("checkNotNull") || access.name().equals("checkNonNull"))
        && access.getNumArg() >= 1 && access.getArg(0).isVariable(var);
  }

  /** Check if this branch has a null-guarding condition.  */
  eq CfgBranch.isNullGuard(Variable var, CfgNode succ) = inNullGuard(var, succ);

  inh boolean CfgBranch.inNullGuard(Variable var, CfgNode succ);

  eq IfStmt.branch().inNullGuard(Variable var, CfgNode succ) =
      succ == getThen().entry()
      ? getCondition().isNonNullTest(var)
      : getCondition().isNullTest(var);

  eq ConditionalExpr.branch().inNullGuard(Variable var, CfgNode succ) =
      succ == getTrueExpr().entry()
      ? getCondition().isNonNullTest(var)
      : getCondition().isNullTest(var);

  eq ForStmt.branch().inNullGuard(Variable var, CfgNode succ) =
      succ == getCondition().follow()
      ? getCondition().isNonNullTest(var)
      : getCondition().isNullTest(var);

  eq WhileStmt.branch().inNullGuard(Variable var, CfgNode succ) =
      succ == getCondition().follow()
      ? getCondition().isNonNullTest(var)
      : getCondition().isNullTest(var);

  eq EnhancedForStmt.branch().inNullGuard(Variable var, CfgNode succ) = false;
  eq DoStmt.branch().inNullGuard(Variable var, CfgNode succ) = false;
  eq SwitchStmt.branch().inNullGuard(Variable var, CfgNode succ) = false;

  /** Returns {@code true} if this set of modifiers includes {@code javax.annotation.Nullable}.  */
  syn boolean Modifiers.hasNullableAnnotation() = hasAnnotation("javax.annotation", "Nullable");

  /** Return {@code true} if this expression is guarded by a != null check for var.  */
  inh boolean Expr.hasNullGuard(Variable var);
  eq Program.getChild().hasNullGuard(Variable var) = false;
  eq IfStmt.getThen().hasNullGuard(Variable var) = getCondition().isNonNullTest(var);
  eq IfStmt.getElse().hasNullGuard(Variable var) = getCondition().isNullTest(var);
  eq WhileStmt.getStmt().hasNullGuard(Variable var) = getCondition().isNonNullTest(var);
  eq ForStmt.getStmt().hasNullGuard(Variable var) = getCondition().isNonNullTest(var);
  eq ConditionalExpr.getTrueExpr().hasNullGuard(Variable var) = getCondition().isNonNullTest(var);
  eq ConditionalExpr.getFalseExpr().hasNullGuard(Variable var) = getCondition().isNullTest(var);
  eq AndLogicalExpr.getRightOperand().hasNullGuard(Variable var) =
      getLeftOperand().isNonNullTest(var) || hasNullGuard(var);
  eq OrLogicalExpr.getRightOperand().hasNullGuard(Variable var) =
      getLeftOperand().isNullTest(var) || hasNullGuard(var);

  syn boolean Expr.isNullTest(Variable var) = false;
  eq EQExpr.isNullTest(Variable var) =
      getLeftOperand().isNull() && getRightOperand().varDecl() == var
      || getRightOperand().isNull() && getLeftOperand().varDecl() == var;
  eq LogNotExpr.isNullTest(Variable var) = getOperand().isNonNullTest(var);
  eq ParExpr.isNullTest(Variable var) = getExpr().isNullTest(var);
  eq AndLogicalExpr.isNullTest(Variable var) =
      getLeftOperand().isNullTest(var) || getRightOperand().isNullTest(var);
  eq OrLogicalExpr.isNullTest(Variable var) =
      getLeftOperand().isNullTest(var) || getRightOperand().isNullTest(var);

  eq AbstractDot.isNullTest(Variable var) =
      !getLeft().isVariable(var) && getRight().isNullTest(var);

  // Assume that a method call to X.isNull_(var) is equivalent to a null test on var.
  eq MethodAccess.isNullTest(Variable var) =
      name().startsWith("isNull") && getNumArg() == 1 && getArg(0).isVariable(var);

  syn boolean Expr.isNonNullTest(Variable var) = false;
  eq NEExpr.isNonNullTest(Variable var) =
      getLeftOperand().isNull() && getRightOperand().varDecl() == var
      || getRightOperand().isNull() && getLeftOperand().varDecl() == var;
  eq LogNotExpr.isNonNullTest(Variable var) = getOperand().isNullTest(var);
  eq ParExpr.isNonNullTest(Variable var) = getExpr().isNonNullTest(var);
  eq AndLogicalExpr.isNonNullTest(Variable var) =
      getLeftOperand().isNonNullTest(var) || getRightOperand().isNonNullTest(var);
  eq OrLogicalExpr.isNonNullTest(Variable var) =
      getLeftOperand().isFalse() && getRightOperand().isNonNullTest(var)
      || getRightOperand().isFalse() && getLeftOperand().isNonNullTest(var);

  eq AbstractDot.isNonNullTest(Variable var) =
      !getLeft().isVariable(var) && getRight().isNonNullTest(var);

  // Assume that a method call to X.isNo{t,n}Null_(var) is equivalent to a non-null test on var.
  eq MethodAccess.isNonNullTest(Variable var) =
      (name().startsWith("isNotNull") || name().startsWith("isNonNull"))
      && getNumArg() == 1 && getArg(0).isVariable(var);

  syn boolean Expr.isNull() = type().isNull();
  eq NullLiteral.isNull() = true;
}
