/**
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Adds an analysis that checks for dereferences of a parameter declared nullable. */
aspect NullableAnalysis {
  refine CloseAnalysis
  protected void Program.initializeLibraryTypes(Map<String, TypeDecl> libs) {
    refined(libs);

    // Inspected types.
    addPlaceholderType(libs, "javax.annotation", "Nullable");
  }

  // Give ParameterDeclaration access to the inherited comilationUnit attribute.
  inh CompilationUnit ParameterDeclaration.compilationUnit();

  ParameterDeclaration contributes nullableDereferenceFinding()
      when nullableDereferenceFinding() != null
      to CompilationUnit.findings()
      for compilationUnit();

  /**
   * Generate a NullableDereference finding for this dot expression,
   * if no finding should be reported this attribute returns {@code null}.
   */
  syn lazy ExtendJFinding ParameterDeclaration.nullableDereferenceFinding() {
    if (!getModifiers().hasNullableAnnotation()) {
      return null;
    }
    if (!isFinal() && !isEffectivelyFinal()) {
      // Do not analyze non-effectively final parameters.
      return null;
    }
    Expr location = findNullableDereference(this);
    if (location == null) {
      return null;
    }
    return location.finding("NullableDereference", String.format(
        "Dereferencing %s, which was declared @Nullable.", name()));
  }

  /**
   * Find a location, not necessarily the first location, in the host method/constructor where the
   * parameter is accessed without a null guard.
   */
  inh Expr ParameterDeclaration.findNullableDereference(Variable var);

  eq Program.getChild().findNullableDereference(Variable var) = null;
  eq BodyDecl.getChild().findNullableDereference(Variable var) = null;

  eq MethodDecl.getParameter().findNullableDereference(Variable var) {
    if (!hasBlock()) {
      return null;
    }
    CfgNode cfgNode = entry().bfs(new NullDereferenceLocator(var));
    return cfgNode == null ? null : cfgNode.receiverExpr();
  }

  eq ConstructorDecl.getParameter().findNullableDereference(Variable var) {
    CfgNode cfgNode = entry().bfs(new NullDereferenceLocator(var));
    return cfgNode == null ? null : cfgNode.receiverExpr();
  }

  /**
   * A CFG visitor that searches in the forward CFG for a nullable dereference.
   * <p>
   * The search stops at parts of the search tree guarded by a null check on the receiver variable.
   */
  class NullDereferenceLocator implements CfgVisitor {
    private final Variable var;

    public NullDereferenceLocator(Variable var) {
      this.var = var;
    }

    @Override public SearchAction processEdge(CfgNode pred, CfgNode succ) {
      if (pred.isNullGuard(var, succ)) {
        return SearchAction.SKIP;
      }
      Expr receiver = succ.receiverExpr();
      if (receiver != null && receiver.isVariable(var) && !receiver.hasNullGuard(var)) {
        return SearchAction.SUCCESSOR_MATCH;
      }
      return SearchAction.CONTINUE;
    }
  }

  /**
   * Returns the receiver expression if the CFG node is the child of a dereferece expression.
   * Returns {@code null} otherwise.
   */
  inh Expr CfgNode.receiverExpr();
  eq Program.getChild().receiverExpr() = null;
  eq BodyDecl.getChild().receiverExpr() = null;
  eq BodyDecl.exit().receiverExpr() = null;
  eq TryStmt.tryEntryMarker().receiverExpr() = null;
  eq BreakStmt.marker().receiverExpr() = null;
  eq ContinueStmt.marker().receiverExpr() = null;
  eq ReturnStmt.marker().receiverExpr() = null;
  eq MethodAccess.exceptionNode().receiverExpr() = null;
  eq MethodAccess.call().receiverExpr() =
      hasPrevExpr()
      ? prevExpr()
      : null;
  eq ThrowStmt.exceptionNode().receiverExpr() = null;
  eq TryStmt.exceptionNode().receiverExpr() = null;
  eq ConditionalExpr.branch().receiverExpr() = null;
  eq ConditionalExpr.thenEndMarker().receiverExpr() = null;
  eq ConditionalExpr.elseEndMarker().receiverExpr() = null;
  eq IfStmt.branch().receiverExpr() = null;
  eq IfStmt.thenEndMarker().receiverExpr() = null;
  eq IfStmt.elseEndMarker().receiverExpr() = null;
  eq ForStmt.branch().receiverExpr() = null;
  eq EnhancedForStmt.branch().receiverExpr() = null;
  eq WhileStmt.branch().receiverExpr() = null;
  eq DoStmt.branch().receiverExpr() = null;
  eq SwitchStmt.branch().receiverExpr() = null;
  eq LambdaBody.exit().receiverExpr() = null;
  eq AbstractDot.nullableDereferenceMarker().receiverExpr() = getLeft();

  /** Marker node used to find location of a nullable dereference in the CFG.  */
  syn nta CfgMarker AbstractDot.nullableDereferenceMarker() = new CfgMarker();

  /** Insert nullable dereference marker in the CFG.  */
  refine SimpleCFG
  eq AbstractDot.getLeft().follow() =
      getRight().isMethodAccess()
      ? refined()
      : nullableDereferenceMarker();

  eq AbstractDot.nullableDereferenceMarker().markerName() = "nullable access";
  eq AbstractDot.nullableDereferenceMarker().markerVarName() = "nullable";
  eq AbstractDot.nullableDereferenceMarker().succ() = Collections.singleton(getRight().entry());

  syn boolean CfgNode.isNullGuard(Variable var, CfgNode succ) = false;

  eq CfgBranch.isNullGuard(Variable var, CfgNode succ) = inhNullGuard(var, succ);

  inh boolean CfgBranch.inhNullGuard(Variable var, CfgNode succ);

  eq IfStmt.branch().inhNullGuard(Variable var, CfgNode succ) =
      succ == getThen().entry()
      ? getCondition().isNonNullTest(var)
      : getCondition().isNullTest(var);

  eq ConditionalExpr.branch().inhNullGuard(Variable var, CfgNode succ) =
      succ == getTrueExpr().entry()
      ? getCondition().isNonNullTest(var)
      : getCondition().isNullTest(var);

  eq ForStmt.branch().inhNullGuard(Variable var, CfgNode succ) = false;
  eq EnhancedForStmt.branch().inhNullGuard(Variable var, CfgNode succ) = false;
  eq WhileStmt.branch().inhNullGuard(Variable var, CfgNode succ) = false;
  eq DoStmt.branch().inhNullGuard(Variable var, CfgNode succ) = false;
  eq SwitchStmt.branch().inhNullGuard(Variable var, CfgNode succ) = false;

  /** Test if this expression refers to a parameter declared as nullable.  */
  syn boolean Expr.isNullableParameter() = varDecl() != null && varDecl().isNullableParameter();

  /** Test if this variable is a parameter declared as nullable.  */
  syn boolean Variable.isNullableParameter() =
      isParameter()
      && (isFinal() || isEffectivelyFinal())
      && declaredNullable();

  /** Test if this variable is declared {@code @Nullable}.  */
  syn boolean Variable.declaredNullable();
  eq FieldDeclaration.declaredNullable() = false;
  eq VariableDeclaration.declaredNullable() = false;
  eq InferredParameterDeclaration.declaredNullable() = false;
  eq ParameterDeclaration.declaredNullable() = getModifiers().hasNullableAnnotation();
  eq CatchParameterDeclaration.declaredNullable() = getModifiers().hasNullableAnnotation();

  syn boolean Modifiers.hasNullableAnnotation() = hasAnnotation("javax.annotation", "Nullable");

  /** Return {@code true} if this expression is guarded by a != null check for var.  */
  inh boolean Expr.hasNullGuard(Variable var);
  eq Program.getChild().hasNullGuard(Variable var) = false;
  eq IfStmt.getThen().hasNullGuard(Variable var) = getCondition().isNonNullTest(var);
  eq IfStmt.getElse().hasNullGuard(Variable var) = getCondition().isNullTest(var);
  eq WhileStmt.getStmt().hasNullGuard(Variable var) = getCondition().isNonNullTest(var);
  eq ForStmt.getStmt().hasNullGuard(Variable var) = getCondition().isNonNullTest(var);
  eq ConditionalExpr.getTrueExpr().hasNullGuard(Variable var) = getCondition().isNonNullTest(var);
  eq ConditionalExpr.getFalseExpr().hasNullGuard(Variable var) = getCondition().isNullTest(var);
  eq AndLogicalExpr.getRightOperand().hasNullGuard(Variable var) =
      getLeftOperand().isNonNullTest(var);
  eq OrLogicalExpr.getRightOperand().hasNullGuard(Variable var) =
      getLeftOperand().isNullTest(var);

  syn boolean Expr.isNullTest(Variable var) = false;
  eq EQExpr.isNullTest(Variable var) =
      getLeftOperand().isNull() && getRightOperand().varDecl() == var
      || getRightOperand().isNull() && getLeftOperand().varDecl() == var;
  eq LogNotExpr.isNullTest(Variable var) = getOperand().isNonNullTest(var);
  eq ParExpr.isNullTest(Variable var) = getExpr().isNullTest(var);
  eq AndLogicalExpr.isNullTest(Variable var) =
      getLeftOperand().isNullTest(var) || getRightOperand().isNullTest(var);
  eq OrLogicalExpr.isNullTest(Variable var) =
      getLeftOperand().isNullTest(var) || getRightOperand().isNullTest(var);

  eq AbstractDot.isNullTest(Variable var) =
      !getLeft().isVariable(var) && getRight().isNullTest(var);

  // Assume that a method call to X.isNull_(var) is equivalent to a null test on var.
  eq MethodAccess.isNullTest(Variable var) =
      name().startsWith("isNull") && getNumArg() == 1 && getArg(0).isVariable(var);

  syn boolean Expr.isNonNullTest(Variable var) = false;
  eq NEExpr.isNonNullTest(Variable var) =
      getLeftOperand().isNull() && getRightOperand().varDecl() == var
      || getRightOperand().isNull() && getLeftOperand().varDecl() == var;
  eq LogNotExpr.isNonNullTest(Variable var) = getOperand().isNullTest(var);
  eq ParExpr.isNonNullTest(Variable var) = getExpr().isNonNullTest(var);
  eq AndLogicalExpr.isNonNullTest(Variable var) =
      getLeftOperand().isNonNullTest(var) || getRightOperand().isNonNullTest(var);
  eq OrLogicalExpr.isNonNullTest(Variable var) =
      getLeftOperand().isFalse() && getRightOperand().isNonNullTest(var)
      || getRightOperand().isFalse() && getLeftOperand().isNonNullTest(var);

  eq AbstractDot.isNonNullTest(Variable var) =
      !getLeft().isVariable(var) && getRight().isNonNullTest(var);

  // Assume that a method call to X.isNo{t,n}Null_(var) is equivalent to a non-null test on var.
  eq MethodAccess.isNonNullTest(Variable var) =
      (name().startsWith("isNotNull") || name().startsWith("isNonNull"))
      && getNumArg() == 1 && getArg(0).isVariable(var);

  syn boolean Expr.isNull() = type().isNull();
  eq NullLiteral.isNull() = true;
}
