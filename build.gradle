buildscript {
	repositories.mavenLocal()
	repositories.maven {
		url 'http://jastadd.org/mvn/'
	}
	dependencies {
		classpath group: 'org.jastadd', name: 'jastaddgradle', version: '1.9.6'
	}
}

apply plugin: 'java'
apply plugin: 'application'
apply plugin: 'jastadd'

repositories {
	mavenLocal()
	flatDir {
		dirs 'third_party/shipshape'
	}
}

// overwrite jastadd2 dependency set by jastaddgradle
configurations {
	all {
		resolutionStrategy.eachDependency { DependencyResolveDetails details ->
			if (details.requested.name == 'jastadd2') {
				details.useVersion '2.1.13'
			}
		}
	}
}

dependencies {
	// TODO(joqvist): Use only the needed transient dependencies from Shipshape,
	// or even better wait for Shipshape to publish on Maven.
	// The shipshape dependency is currently a fat jar built from the Shipshape repo.
	compile name: "java_dispatcher_deploy"

	compile group: 'com.google.guava', name: 'guava', version: '18.0'
	testCompile group: 'com.google.truth', name: 'truth', version: '0.27'
}

jastadd {
	modules 'modules' // Module source.
	module = 'simplecfg' // The module to build.

	astPackage = 'com.google.simplecfg.ast'
	genDir = 'src/gen/java'
	parser.name = 'JavaParser'
}

generateJava << {
	ant.copy file: file('third_party/extendj/git/java8/src/org/extendj/scanner/JavaScanner.java'),
		todir: file('src/gen/java/org/extendj/scanner'),
		overwrite: true
	ant.replace file: file('src/gen/java/org/extendj/scanner/JavaScanner.java'),
		token: 'org.extendj',
		value: 'com.google.simplecfg'
}

test {
	inputs.dir file('testdata')
}

mainClassName = 'com.google.simplecfg.PrintCfg'
jar.manifest.attributes 'Main-Class': mainClassName
jar.destinationDir = projectDir

sourceCompatibility = '1.8'
targetCompatibility = '1.8'

task deployJar(type: Jar, description: 'Build a docker image for the SimpleCFG based analyzers.') {
	manifest.attributes 'Main-Class': 'com.google.shipshape.extendj.ExtendJService'
	baseName = 'deploy_jar'
	from { configurations.compile.collect {
		it.isDirectory() ? it : zipTree(it)
	} }
	with jar
}

task('docker', dependsOn: [ 'deployJar' ]) {
	description 'Build the docker image.'

	inputs.file 'src/main/docker/entrypoint.sh'

	doLast {
		copy {
			from 'src/main/docker'
			into "${temporaryDir}"
		}
		copy {
			from deployJar.destinationDir
			into "${temporaryDir}"
			include deployJar.archiveName
		}
		def dockerfile = new File(getTemporaryDir(), 'Dockerfile')
		dockerfile.withWriter('utf-8') { writer ->
			writer.writeLine 'FROM java:8'
			writer.writeLine "ADD ${deployJar.archiveName} /java_service.jar"
			writer.writeLine 'ADD /entrypoint.sh /entrypoint.sh'
			writer.writeLine 'EXPOSE 10005'
			writer.writeLine 'ENTRYPOINT ["/entrypoint.sh"]'
		}
		tryCommand("docker build -t extendj_shipshape/extendj ${temporaryDir}".split())
	}
}

/**
 * Helper method for running a shell command in a build task.
 * Returns the command output if the command succeeded, otherwise returns an empty string.
 */
def tryCommand(command, failOnError = true) {
	def out = new StringBuilder()
	def err = new StringBuilder()
	def proc = command.execute()
	proc.waitForProcessOutput(out, err)
	if (proc.exitValue()) {
		def msg = "failed to run '${command[0]}' (args: ${command.tail()})\n$err$out"
		if (failOnError) {
			throw new GradleException(msg)
		} else {
			print 'Warning: '
			println msg
		}
		""
	} else {
		if (err) println "${err}"
		out.toString()
	}
}
